소프트웨어 테스트란?
   : 동작하는지 확인하기 위함, 소프트웨어가 의도한 대로(고객의 요구사항에 맞게)
   돌아가는지 확인하는 것
   : 이전에는 개발자는 개발만, 테스트는 QA팀에서 알아서 진행 => 역할 분리
   : 최근에 트렌드가 바뀌기 시작함 개발자가 자동화할 수 있는 영역까지는 모두 테스트를 적용하여 구현

   개발자 테스트 -> 자동화 테스트
   메뉴얼 테스트 -> 사람들이 직접 눌러보는 수동 테스트

   이점
      1. 컴퓨터를 통한 테스트 => 사람의 테스트보다 빠름
      2. 정해진 스크립트나 순서에 따라 일관성 있게 동작하기 때문에
         사람이 테스트하는 것보다 에러를 피할 수 있는 가능성이 높아짐
         ex) 버튼을 누르면 자동으로 해당 테스트를 실행
      3. 사람이 하는 것보다 싸다
      4. 피드백을 빠른 주기로 개발 도중에 받을 수 있다
   
테스트의 종류
   1. 유닛테스트  : 가장 간단, 가장 작은 범위 (한가지의 기능)
   2. 통합테스트  : 모듈끼리의 결합도, 동작을 잘 수행하는지
                  ex) 컴포넌트에서 렌더링이 이루어지는가
                  => 가성비가 제일 좋은 테스트
   3. E2E TEST    : End to End 끝에서부터 끝까지 배포 직전
                  실질 사용자가 애플리케이션 직접 사용하는 것처럼 테스트
                  실제 유저의 동작을 흉내, 많은 시간과 소스코드가 필요

프론트엔드 E2E TEST 
   : 실제 브라우저와 유사한 환경 구축 => 실제로 여러 동작을 실행
   실제 브라우저와 유사한 환경 
      : Cypress와 같은 크롬과 비슷한 브라우저 환경 구축 테스트 라이브러리

테스트 하는 방법
   테스트 툴은 대표적으로 mocha, chai, jest
   npm trends에 의하면 순위는 1800만 jest, 700만 mocha, chai
   cra => jest를 포함한 여러가지 구축 라이브러리 이미 설치/세팅 완료

jest 사용법
   1. *.test.* <= 이렇게 생긴 파일은 모두 테스트 파일로 인식
      제스트 실행 시 해당 파일을 모두 찾아서 테스트를 실행
      ex) todo.test.jsx
   2. 아니면 __test__ 폴더로 따로 관리

리팩터링(리팩토링)
   : 결과는 같지만 내부의 로직을 개선(다른 로직으로 변경 X, 개선 O)
TDD (Test Drive Development)
   : 테스트를 주도로 개발하는 개발 방법론

   보통 테스트  : 코드를 작성하고 테스트
   TDD         : 테스트 먼저 작성하고 코드를 작성

   RGB
      red -> 구현 전에 테스트 코드 작성 -> 무조건 실패 -> 실패하는 코드가 생김
      (코드가 먼저 설계, 설계된 코드를 바탕으로 실제 코드를 작성)
      green -> 테스트 통과를 위해 작성 코드가 통과된 상태
      blue -> 더 좋은 코드의 형태로 리팩터링 => 지속적으로 테스트 통과하는지 확인

   이점
      1. 코드 작성 과정에 확신
      2. 구현이 잘못된 경우 바로 확인이 가능
      3. 코드의 동작이 명확 => 구조가 깔끔하게 짜여짐
   단점
      1. 현저하게 떨어지는 생산성

테스트코드 작성
   jest 사용법
      1. 특정 동작을 수행
      2. 매처함수를 통해 해당 값이 예측하고 있는 값과 일치하는지 검증
      ex)
         test("addNum", () => {
            expect(2 + 2).toBe(4)
         }) // 통과
         test or it("테스트명" () => {
            expect(결과값).matcher(예측값)
         })
      test나 it은 동작 상의 차이는 없음

   matcher의 종류
      1. tobe (===)
      2. toEqual
         obj의 경우 값이 같아도 참조 값이 다르기 때문에 ===으로 비교하면 서로 일치X
         따라서 객체를 반복하면서(재귀적) 두 객체의 값이 동일한지 판단한 후 결과를 
         내보내는 toEqual 사용
         ex)
            const obj = {hello:"world"}
            expect(obj).toBe({hello:"world"})    ---> X
            expect(obj).toEqual({hello:"world"}) ---> O
         그 외
            toBeNull, toBeUndefined
            toBeGreaterThen, toBeLessThen, toBeLessThenOrEqual

      3. toContain : iterable(순회 가능한) 객체들이 특정 요소를 포함하고 있는지 
                  검증할 때 사용할 수 있음
         ex) 
            const iterable = [1, 2, 3, 4, 5]
            expect(iterable).toContain(3) === o

            describe("테스트명", () => {
               test(() => {
                  //TODO
               })...
               test()...
               test()...
            })

   react의 테스트
      브라우저의 렌더링
         대표적인 컴포넌트 테스트 라이브러리는 RTL(React Testing Library과 enzyme
      enzyme => 구현과 기능
      RTL => 결과를 테스트하는데 맞춰져 있음 (유저의 행동과 유사하게)

      이 중 어떤 것을 써야하는지는 명확하게 존재하지 않는다
      경우와 목적에 따라서 두 개 모두 테스트하기도 함

      1. 구현
         버튼을 클릭하면 state가 변하고 이것이 UI에 반영
      2. 결과
         유저의 행동을 기반 만약 버튼을 눌렀을 때 회원가입이 됬다라는 결과가 존재한다면
         그 안에 내부로직이나 과정은 어떻게 바뀌든 상관이 없다는 것
      
      테스트코드는 클린코드로 작성할 필요가 있는가? (논쟁 多)
         1. 더티코드는 테스트코드를 수정하는데 있어서 또 시간이 걸림
            -> 테스트를 안하게 됨 -> 테스트를 자신이 직접 하게 됨
         2. 테스트 코드를 클린하게 짜지 않아서 시간이 걸리는 것이다

         RTL은 유저 행동 기반
         따라서 state나 props에 접근하여 값을 기대할 수 없다
         그러나 user-enver(가상의 유저)를 통해 클릭이나 행동에 다른 결과값을 유추
      
      RTL은 실제 브라우저 환경이 아니기 때문에 dom 객체 불가능
      따라서 jest dom과 함께 테스트용 dom을 만들어준다
         ex)
            tobeIntheDocument
            toBeDisabled
         등과 같은 dom(태그, 요소)와 관련된 매쳐함수를 사용할 수 있음

App.test.js
   const linkElement = screen.getByText(/learn react/i); 
   expect(linkElement).toBeInTheDocument();
   
CI/CD
   테스트 해주고 => CI
   git push할 때마다 server reload => CD