채용툴
   로켓펀치
   원티드
공부
   JavaScript MDN
---------------------------------------------------------------------------

    실행컨텍스트

    "this"
    "스코프"
    "컨텍스트"
    "클로저"

----------------------------------------------------------------------------

    자바스크립트의 실행컨텍스트
    : 자바스크립트가 실행되고 있는 환경을 정의한 것 
    여기서 환경이란 this, 변수, 상수, 함수, 객체 등 코드 실행에 필요한 기반

    스코프: 구역 -> 실행 컨텍스트로 구현하고자하는 최종 목표
    (변수, 상수와 같은 환경들에 영역을 정의하고 구분짓는다)

    스코프 체인: 참조하려고 하는 값이 해당 컨텍스트에 존재하지 않으면 바로 상위
    의 스코프의 컨텍스트에서 값을 참조


----------------------------------------------------------------------------

    실행컨텍스트의 종류

    1. Global Execution Context(전역 실행 컨텍스트)
        처음으로 자바스크립트 코드가 실행될 때 생성되는 컨텍스트
        이 컨텍스트에서는 전역으로 관리되는 값을 관리


    2. Function Execution Context(함수 실행 컨텍스트)
        각 함수가 실행(선언X 실행o)될 때 마다 생성되는 컨텍스트

    3. 그 외 (Eval Execution, Modul Execution)

----------------------------------------------------------------------------

    콜스택

    큐--?[FIFO] // First In First Out
      [이벤트큐(테스트 큐)]
    스택 --?[LIFO] // Last In First Out
      [콜스택]

    흐름

    1. 비어있는 컨텍스트
    2. 전역 컨텍스트 생성, 전역 스코프에 변수,함수가 평가
    3. 다른 함수가 실행되면서 함수 컨텍스트 생성(이때 함수 컨텍스트 평가)
    4. 함수 안에서 또 다른 함수 (3) 실행
    5. 실행이 다 되면 컨텍스트 제거
    6. 모든 실행컨텍스트가 종료되면 컨텍스트 스택에서 제거

----------------------------------------------------------------------------

    1. 평가
        실행 컨텍스트틑 생성한 뒤 변수 함수 선언문들을 파악하여 현재 스코프(구역)에서
        사용이 가능한 변수,함수,식별자 등을 컨텍스트을 등록

        "호이스팅"이란 것은 사실상 자바스크립트 언어 자체에서 존재하지 않는 말
        다만 평가 과정에서 식별자에 의해 값이 할당되기 전에 선언이 먼저 기독되기
        때문에 개발자들 사이에서 호이스팅이라고 이름을 붙인 것 뿐

    2. 실행
        선언문을 제외한 호출, 런타임, 실행과젱에서 소스코드에 필요한 정보 , 즉
        변수나 함수의 참조를 실행 컨텍스트에 등록된 것에부터 찾고 실행 과정에서
        변수의 값이 변경되면 재등록

----------------------------------------------------------------------------

    실행컨텍스트 내부 

    실행컨텍스트는 객체처럼 여러가지의 프로퍼티를 갖고 있음
    대표적으로 LexicalEnvironment가 있음

    렉시컬 환경은 스코프를 관리, 이 안에서 변수 함수 값들이 저장
    렉시컬 환경은 크게 두가지 영역

    Enviroment Record:
        식별자를 등록하는 관리하는 역할

    OuterLexcialEnvirmentReference: 
        상위 스코프를 참조, 이를 통해 상위 스코프 영역에있는 변수들을 사용 가능

    1. 식별자 생성
    2. this binding
    3. 참조할 외부 컨텍스트 결정
    4. 실행 과정에서 혹은 평과과정에서 생성된 정보들을 기반으로 값을 변경 -> 재등록

 -----------------------------------------------------------------------------

    * this
        "누가 나를 불렀냐"
        
        즉 this의 값은 선언이 아닌 호출(누가 불렀느냐)에 따라 달라질 수 박에 없음
        => this 해당 메서드를 호출한 객체로 바인딩

      전역 함수 호출 했을 시 해당 함수의 this는 window가 됩니다.
      함수의 주인은 window

      this는 기본적으로는 window지만, 
      use strict;에서는 undefined => 디폴트 바인딩을 진행하지 않기 때문이다

      객체나 메서드, bind call, apply, new 일 때
      그리고 이벤트리스너나, 라이브러리에 의해 
      this는 유동적으로 변경됩니다.

-----------------------------------------------------------------------------

  전역 실행 컨텍스트

  자바스크립트 코드가 실행되면서 먼저 전역 객체가 생성 
  전역 객체에는 자바스크립트에서 기본적으로 포함되어있는 빌트인 객체, 함수, 객체
  를 포함합니다

  이러한 전역 객체 평가되면서 전역 실행 컨텍스트가 생성
  
  전역 실행 컨텍스트 두가지의 프로퍼티를 가지고 있음

  Declartive Environment Record
  : let과 const고 선언한 변수를 따로 관리
  여기에서 저장된 식별자들은 선언과 초기화가 분리되어 실행
  따라서 var로 선언한 변수와 함수선언과는 다르게 초기화전 까지는 접근 불가능(참조 에러)

  Object Enviroment Record
  : 그 외 영역을 관리(표준 빌트인 객체, 전역 함수, var...)

  빌트인 객체: ECMAScript(es)에 의해 정이된 기본 객체 
  (실행컨텍스트와 상관없이 사용가능 (Math, Date....))

  -----------------------------------------------------------------------------
 
   LexicalEnviroment와 실행컨텍스트 별도로 관리
   LexicalEnviroment에서 참조되는 객체가 있다면 실행컨텍스트는 삭제되도
   LexicalEnviroment는 삭제되지 않습니다.

   LexicalEnviroment 삭제되는 것은 참조 카운트가 0이 되었을 때
   이러한 원리에 의해 클로저를 구현할 수 있음

  -----------------------------------------------------------------------------

 클로저

    클로즈는 자바스크립트만의 개념은
    함수를 일급객체(함수를 선언하고 컴파일[번역] 및 런타임[실행] 할 수 있는 언어)
    로 사용하는 모든 언어에서 사용되는 특성

    "클로저는 자신의 생성될 때의 환경을 기억하고, 그를 사용하는 함수이다"

    ex) 

    funcgion addNumFunction(num) {
        cont toAdd = num

        return function (number) {
            return number + todAdd
        }
    }


   const add5 =  addNumFunction(5) // function

   add5(3) // 8
   add5(8) // 13
   클로즈 = 닫혀있다 (범위가 정해짐)

 -----------------------------------------------------------------------------

   * 클로저 사용 예시

   1. 상태은닉 

   2. 상태공유
    const makeStudent = (function makeCalss(teacher) {
        return funcgion (name) {
            return {
                name: name
                getTeacher: () => teacher,
                setTeacher: name => {}
                    teacher = name
            }
        }
    }
    )("성용")

    
    const 철수 = makeStudent("철수")
    const 영희 = makeStudent("영희")
    const 미나 = makeStudent("영희")

    철수.getTeacher = 성용
    철수.setTeacher = 용성
    철수.getTeacher = 용성

   3. 상태기억
    
   "4. 메모이제이션(캐시) - 보류"

        값을 저장해두었다가 사용하는 것
        값이 바뀌지 않으면 저장해둔 값을 사용

        ex)
        1(매개변수,input) => (연산) => 결과값(output) 5
        2..3..4..

        1 => 연산(x) => 결과값 5